/*
 * Copyright (c) 2022, Connect Tech Inc.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//#include "tegra234-orin-agx-cti-csi.dtsi"
#include "dt-bindings/clock/tegra234-clock.h"

#define RST_IO_EXP TEGRA234_MAIN_GPIO(AC,1)
#define PWM_CALIB_GPIO TEGRA234_MAIN_GPIO(H,7) //CAM0_PWDN
#define TRIGGER_SEL TEGRA234_MAIN_GPIO(I,0) //CAM0_RST
#define PWR_EN        TEGRA234_MAIN_GPIO(AC, 7)
#define CAM_LANES 2
#define CAM_LANES_STRING "2" 
#define TEGRA_SINTERFACE "serial_g"
#define MODE_VC "0"

#include "tegra234-orin-agx-cti-camera-SL-ZEDX-modes.dtsi"

/ {

    gpio@2200000 {
        camera-control-output-high {
            status = "okay";
            gpio-hog;
            gpios = <RST_IO_EXP 0>;
            output-high;
            label = "rst-io-expender"; 
        };
        camera-control-output-low {
            status = "okay";
            gpio-hog;
            gpios = <TRIGGER_SEL 0>;
            output-low;
            label = "trigger_sel";
        };
    };

    

    i2c@31e0000 {
    status = "okay";
    #address-cells = <1>;
    #size-cells = <0>;
    tca9544@72 {
        status = "okay";
        compatible = "nxp,pca9544";
        reg = <0x72>;
        #address-cells = <1>;
        #size-cells = <0>;
        vcc-supply = <&vdd_1v8_sys>;
        vcc-pullup-supply = <&battery_reg>;
        vcc_lp = "vcc";
        skip_mux_detect = "yes";
        force_bus_start = <0x1e>;
        i2c@0 {
            status = "okay";
            reg = <0>;
            i2c-mux,deselect-on-exit;
            #address-cells = <1>;
            #size-cells = <0>;

            /* deserializer MAX9296 at address 0x48*/
            max929x_a@48 {
                compatible = "stereolabs,sl-max929x";
                reg = <0x48>;
                channel = "a";
            };

            bmi088@69 {
                compatible = "bmi,bmi088";
                reg = <0x69>;
                status = "okay";
                accel_i2c_addr = <0x19>;
                accel_matrix = [01 00 00 00 01 00 00 00 01];
                gyro_matrix = [01 00 00 00 01 00 00 00 01];
            };
        
            /* ZED1 Left Cam*/
            zedx_left_0@18 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x18>;
                def-addr = <0x18>;
                devnode = "video0";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "a";
                mode = "master";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM1";
				sync_sensor_index = <1>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
                
                /* For now, the master get the gpios */
                /* In the future, the deserializer will get them */
                reset-gpios = <&tca9539_74 0 GPIO_ACTIVE_HIGH>;
                pwdn-gpios = <&tca9539_74 1 GPIO_ACTIVE_HIGH>;
                pwr-gpios = <&tegra_main_gpio PWR_EN GPIO_ACTIVE_HIGH>;
                ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
                    
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        cam_out0: endpoint {
                            vc-id = <0>;
                            port-index = <6>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&csi_in0>;
                        };
                    };
                };    

            };

            zedx_right_0@10 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x10>;
                def-addr = <0x10>;
                devnode = "video1";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "a";
                mode = "slave";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM1";
				sync_sensor_index = <2>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
                
//#undef TEGRA_SINTERFACE
//#define TEGRA_SINTERFACE "serial_g"
#undef MODE_VC
#define MODE_VC "1"
                ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2    
            
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        cam_out1: endpoint {
                            vc-id = <1>;
                            port-index = <6>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&csi_in1>;
                        };
                    };
                };    
            };
         
        };

        i2c@1 {
        status = "okay";
        reg = <1>;
        i2c-mux,deselect-on-exit;
        #address-cells = <1>;
        #size-cells = <0>;
        
        /* deserializer MAX9296 at address 0x48*/
        max929x_a@48 {
            compatible = "stereolabs,sl-max929x";
            reg = <0x48>;
            channel = "b";
        };

        bmi088@69 {
            compatible = "bmi,bmi088";
            reg = <0x69>;
            status = "okay";
            accel_i2c_addr = <0x19>;
            accel_matrix = [01 00 00 00 01 00 00 00 01];
            gyro_matrix = [01 00 00 00 01 00 00 00 01];
            //accelerometer_irq_gpio = //figure out later
        };
    
        zedx_left_1@18 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x18>;
                def-addr = <0x18>;
                devnode = "video2";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "b";
                mode = "master";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM2";
				sync_sensor_index = <1>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
                
                /* For now, the master get the gpios */
                /* In the future, the deserializer will get them */
                reset-gpios = <&tca9539_74 2 GPIO_ACTIVE_HIGH>;
                pwdn-gpios = <&tca9539_74 3 GPIO_ACTIVE_HIGH>;
                pwr-gpios = <&tegra_main_gpio PWR_EN GPIO_ACTIVE_HIGH>;
#undef TEGRA_SINTERFACE
#define TEGRA_SINTERFACE "serial_e"
#undef MODE_VC
#define MODE_VC "0"    

            ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
    
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    cam_out2: endpoint {
                        vc-id = <0>;
                        port-index = <4>;
                        bus-width = <CAM_LANES>;
                        remote-endpoint = <&csi_in2>;
                    };
                };
            };    

        };

        zedx_right_1@10 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x10>;
                def-addr = <0x10>;
                devnode = "video3";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "b";
                mode = "slave";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM2";
				sync_sensor_index = <2>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
#undef MODE_VC
#define MODE_VC "1"
            ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
        
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    cam_out3: endpoint {
                        vc-id = <1>;
                        port-index = <4>;
                        bus-width = <CAM_LANES>;
                        remote-endpoint = <&csi_in3>;
                    };
                };
            };    
        };
        };


        i2c@2 {
            status = "okay";
            reg = <2>;
            i2c-mux,deselect-on-exit;
            #address-cells = <1>;
            #size-cells = <0>;
        
            /* deserializer MAX9296 at address 0x48*/
            max929x_a@48 {
                compatible = "stereolabs,sl-max929x";
                reg = <0x48>;
                channel = "c";
            };

            bmi088@69 {
                compatible = "bmi,bmi088";
                reg = <0x69>;
                status = "okay";
                accel_i2c_addr = <0x19>;
                accel_matrix = [01 00 00 00 01 00 00 00 01];
                gyro_matrix = [01 00 00 00 01 00 00 00 01];
                //accelerometer_irq_gpio = //figure out later
            };


            zedx_left_2@18 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x18>;
                def-addr = <0x18>;
                devnode = "video4";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "c";
                mode = "master";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM3";
				sync_sensor_index = <1>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
                
                /* For now, the master get the gpios */
                /* In the future, the deserializer will get them */
                reset-gpios = <&tca9539_74 4 GPIO_ACTIVE_HIGH>;
                pwdn-gpios = <&tca9539_74 5 GPIO_ACTIVE_HIGH>;
                pwr-gpios = <&tegra_main_gpio PWR_EN GPIO_ACTIVE_HIGH>;
#undef TEGRA_SINTERFACE
#define TEGRA_SINTERFACE "serial_c"
#undef MODE_VC
#define MODE_VC "0"    

                ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
        
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        cam_out4: endpoint {
                            vc-id = <0>;
                            port-index = <2>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&csi_in4>;
                        };
                    };
                };    

            };

            zedx_right_2@10 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x10>;
                def-addr = <0x10>;
                devnode = "video5";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "c";
                mode = "slave";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM3";
				sync_sensor_index = <2>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
#undef MODE_VC
#define MODE_VC "1"
                ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
            
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        cam_out5: endpoint {
                            vc-id = <1>;
                            port-index = <2>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&csi_in5>;
                        };
                    };
                };    
            };
        };
                
        i2c@3 {
        status = "okay";
        reg = <3>;
        i2c-mux,deselect-on-exit;
        #address-cells = <1>;
        #size-cells = <0>;
                

        /* deserializer MAX9296 at address 0x48*/
        max929x_a@48 {
            compatible = "stereolabs,sl-max929x";
            reg = <0x48>;
            channel = "d";
        };

        bmi088@69 {
            compatible = "bmi,bmi088";
            reg = <0x69>;
            status = "okay";
            accel_i2c_addr = <0x19>;
            accel_matrix = [01 00 00 00 01 00 00 00 01];
            gyro_matrix = [01 00 00 00 01 00 00 00 01];
            //accelerometer_irq_gpio = //figure out later
        };
        zedx_left_3@18 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x18>;
                def-addr = <0x18>;
                devnode = "video6";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "d";
                mode = "master";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM4";
				sync_sensor_index = <1>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
                
                /* For now, the master get the gpios */
                /* In the future, the deserializer will get them */
                reset-gpios = <&tca9539_74 6 GPIO_ACTIVE_HIGH>;
                pwdn-gpios = <&tca9539_74 7 GPIO_ACTIVE_HIGH>;
                pwr-gpios = <&tegra_main_gpio PWR_EN GPIO_ACTIVE_HIGH>;
#undef TEGRA_SINTERFACE
#define TEGRA_SINTERFACE "serial_a"
#undef MODE_VC
#define MODE_VC "0"    

            ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
    
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    cam_out6: endpoint {
                        vc-id = <0>;
                        port-index = <0>;
                        bus-width = <CAM_LANES>;
                        remote-endpoint = <&csi_in6>;
                    };
                };
            };    

        };

        zedx_right_3@10 {
                status = "okay";
                compatible = "stereolabs,zedx";
                reg = <0x10>;
                def-addr = <0x10>;
                devnode = "video7";
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
                        <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                channel = "d";
                mode = "slave";
                has-eeprom;
                
                /* Physical dimensions of sensor */
				physical_w = "15.0";
				physical_h = "12.5";

				vertical-flip = "true";
				sensor_model ="zedx";
				sync_sensor = "ZED_CAM4";
				sync_sensor_index = <2>;
                
                post_crop_frame_drop = "0";
                use_sensor_mode_id = "true";
#undef MODE_VC
#define MODE_VC "1"
            ZEDX_SENSOR_MODE0
                ZEDX_SENSOR_MODE1
                ZEDX_SENSOR_MODE2
        
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    cam_out7: endpoint {
                        vc-id = <1>;
                        port-index = <0>;
                        bus-width = <CAM_LANES>;
                        remote-endpoint = <&csi_in7>;
                    };
                };
            };    
        };
        
        };
        };
    };

    i2c@3180000 {
        status = "okay";
        #address-cells = <1>;
        #size-cells = <0>;
        tca9539_74: tca9539@74 {
            compatible = "ti,tca9539";
            gpio-controller;
            #gpio-cells = <2>;
            ngpios = <16>;
            reg = <0x74>;
            vcc-supply = <&battery_reg>;
            status = "okay";
            
            tca9539_74_outlow {
                status = "okay";
                gpio-hog;
                gpios = <0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0>;
                output-low;
                label = "RST_A","PWDN_A","RST_B","PWDN_B","RST_C","PWDN_C","RST_D","PWDN_D";
            };
            tca9539_74_outhigh {
                status = "disabled";
            };
            tca9539_74_input {
                status = "disabled";
            };
        };
    };
    tegra-capture-vi {
        status = "okay";
        num-channels = <8>;
        ports {
        #address-cells = <1>;
        #size-cells = <0>;
        status = "okay";
            port@0 {
        reg = <0>;
                status = "okay";
                vi_in0: endpoint {
            vc-id = <0>;
                    port-index = <5>;
                    status = "okay";
                    bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out0>;
                };
            };
            port@1 {
                status = "okay";
        reg = <1>;
                vi_in1: endpoint {
            vc-id = <1>;
                    port-index = <5>;
                    status = "okay";
                    bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out1>;
                };
            };
        port@2 {
        status = "okay";
        reg = <2>;
        vi_in2: endpoint {
            vc-id = <0>;
            port-index = <4>;
            bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out2>;
            status = "okay";
        };
        };
        port@3{
        status = "okay";
        reg = <3>;
        vi_in3: endpoint {
            vc-id = <1>;
            port-index = <4>;
            bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out3>;
            status = "okay";
        };
        };
        port@4 {
        status = "okay";
        reg = <4>;
        vi_in4: endpoint {
            vc-id = <0>;
            port-index = <2>;
            bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out4>;
            status = "okay";
        };
        };
        port@5 {
        status = "okay";
        reg = <5>;
        vi_in5: endpoint {
            vc-id = <1>;
            port-index = <2>;
            bus-width = <CAM_LANES>;
            remote-endpoint = <&csi_out5>;
            status = "okay";
        };
        };
            port@6 {
                status = "okay";
        reg = <6>;
                vi_in6: endpoint {
                    port-index = <0>;
                    status = "okay";
                    bus-width = <CAM_LANES>;
            vc-id = <0>;
            remote-endpoint = <&csi_out6>;
                };
            };
            port@7 {
                status = "okay";
        reg = <7>;
                vi_in7: endpoint {
                    port-index = <0>;
                    status = "okay";
                    bus-width = <CAM_LANES>;
            vc-id = <1>;
            remote-endpoint = <&csi_out7>;
                };
            };
        };
    };

    host1x@13e00000 {
        nvcsi@15a00000 {
        num-channels = <8>;
        #address-cells = <1>;
        #size-cells = <0>;
            status = "okay";
            channel@0 {
                status = "okay";
        reg = <0>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    port@0 {
                        status = "okay";
            reg = <0>;
                        csi_in0: endpoint@0 {
                            status = "okay";
                            port-index = <6>;
                vc-id = <0>;
                bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out0>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out0: endpoint@1 {
                            status = "okay";
                port-index = <6>;
                vc-id = <0>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in0>;
                        };
                    };
                };
            };
            channel@1 {
                status = "okay";
        reg = <1>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    
            port@0 {
            reg = <0>;
                        status = "okay";
                        csi_in1: endpoint@2 {
                            status = "okay";
                port-index = <6>;
                vc-id = <1>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out1>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out1: endpoint@3 {
                            status = "okay";
                port-index = <6>;
                vc-id = <1>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in1>;
                        };
                    };
                };
            };
        channel@2 {
                status = "okay";
        reg = <2>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    port@0 {
                        status = "okay";
            reg = <0>;
                        csi_in2: endpoint@4 {
                            status = "okay";
                            port-index = <4>;
                bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out2>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out2: endpoint@5 {
                            status = "okay";
                port-index = <4>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in2>;
                        };
                    };
                };
            };
            channel@3 {
                status = "okay";
        reg = <3>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    
            port@0 {
            reg = <0>;
                        status = "okay";
                        csi_in3: endpoint@6 {
                            status = "okay";
                port-index = <4>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out3>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out3: endpoint@7 {
                            status = "okay";
                port-index = <4>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in3>;
                        };
                    };
                };
            };
        channel@4 {
                status = "okay";
        reg = <4>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    port@0 {
                        status = "okay";
            reg = <0>;
                        csi_in4: endpoint@8 {
                            status = "okay";
                            port-index = <2>;
                bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out4>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out4: endpoint@9 {
                            status = "okay";
                port-index = <2>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in4>;
                        };
                    };
                };
            };
            channel@5 {
                status = "okay";
        reg = <5>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    
            port@0 {
            reg = <0>;
                        status = "okay";
                        csi_in5: endpoint@10 {
                            status = "okay";
                port-index = <2>;
                            bus-width = <CAM_LANES>;
                            remote-endpoint = <&cam_out5>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out5: endpoint@11 {
                            status = "okay";
                port-index = <2>;
                bus-width = <CAM_LANES>;
                remote-endpoint = <&vi_in5>;
                        };
                    };
                };
            };

            channel@6 {
                status = "okay";
        reg = <6>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    port@0 {
            reg = <0>;
                        status = "okay";
                        csi_in6: endpoint@12 {
                            status = "okay";
                            bus-width = <CAM_LANES>;
                port-index = <0>;
                remote-endpoint = <&cam_out6>;
                        };
                    };
                    port@1 {
                        status = "okay";
                        reg = <1>;
            csi_out6: endpoint@13 {
                            status = "okay";
                remote-endpoint = <&vi_in6>;
                        };
                    };
                };
            };

            channel@7 {
                status = "okay";
        reg = <7>;
                ports {
            #address-cells = <1>;
            #size-cells = <0>;
                    port@0 {
            reg = <0>;
                        status = "okay";
                        csi_in7: endpoint@14 {
                            status = "okay";
                            bus-width = <CAM_LANES>;
                port-index = <0>;
                remote-endpoint = <&cam_out7>;
                        };
                    };
                    port@1 {
                        status = "okay";
            reg = <1>;
                        csi_out7: endpoint@15 {
                            status = "okay";
                remote-endpoint = <&vi_in7>;
                        };
                    };
                };
            };
        };
    };


    tegra-camera-platform {
        num_csi_lanes = <8>;
        max_lane_speed = <4000000>;
        min_bits_per_pixel = <10>;
        vi_peak_byte_per_pixel = <2>;
        vi_bw_margin_pct = <25>;
    //max_pixel_rate = <750000>;
        isp_peak_byte_per_pixel = <5>;
        isp_bw_margin_pct = <25>;
    compatible = "nvidia, tegra-camera-platform";
    status = "okay";
        
    modules {
        status = "okay";
        module0 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "bottomleft";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 30-0018";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@0/zedx_left_0@18";
            };
            
        };
        module1 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "bottomright";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 30-0010";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@0/zedx_right_0@10";    
            };
        };
        module2 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "topleft";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 31-0018";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@1/zedx_left_1@18";
            };
        };
        module3 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "topright";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 31-0010";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@1/zedx_right_1@10";
            };
        };
        module4 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "centerleft";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 32-0018";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@2/zedx_left_2@18";
            };
        };
        module5 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "centerright";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 32-0010";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@2/zedx_right_2@10";
            };
        };
        module6 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "backleft";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 33-0018";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@3/zedx_left_3@18";
            };
        };
        module7 {
            status = "okay";
            badge = "zedx_ar0234";
            position = "backright";
            orientation = "1";
            drivernode0 {
                status = "okay";
                pcl_id = "v4l2_sensor";
                devname = "zedx 33-0010";
                proc-device-tree = "/proc/device-tree/i2c@31e0000/tca9544@72/i2c@3/zedx_right_3@10";
            };
        };
        
        };
    };
};
